// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEMON_DEMON_H_
#define FLATBUFFERS_GENERATED_DEMON_DEMON_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace demon {

struct Inotify;
struct InotifyBuilder;

struct TCPSocket;
struct TCPSocketBuilder;

struct SurveillanceEvent;
struct SurveillanceEventBuilder;

struct RunCommand;
struct RunCommandBuilder;

struct KillProcess;
struct KillProcessBuilder;

struct ProcessLaunched;
struct ProcessLaunchedBuilder;

struct ChildCreationError;
struct ChildCreationErrorBuilder;

struct ProcessTerminated;
struct ProcessTerminatedBuilder;

struct TCPSocketListening;
struct TCPSocketListeningBuilder;

struct InotifyPathUpdated;
struct InotifyPathUpdatedBuilder;

struct InotifyWatchListUpdated;
struct InotifyWatchListUpdatedBuilder;

struct SocketWatched;
struct SocketWatchedBuilder;

struct SocketWatchTerminated;
struct SocketWatchTerminatedBuilder;

struct EstablishTCPConnection;
struct EstablishTCPConnectionBuilder;

struct EstablishUnixConnection;
struct EstablishUnixConnectionBuilder;

struct Message;
struct MessageBuilder;

enum InotifyEvent : int8_t {
  InotifyEvent_modified = 0,
  InotifyEvent_created = 1,
  InotifyEvent_size_reached = 2,
  InotifyEvent_deleted = 3,
  InotifyEvent_accessed = 4,
  InotifyEvent_MIN = InotifyEvent_modified,
  InotifyEvent_MAX = InotifyEvent_accessed
};

inline const InotifyEvent (&EnumValuesInotifyEvent())[5] {
  static const InotifyEvent values[] = {
    InotifyEvent_modified,
    InotifyEvent_created,
    InotifyEvent_size_reached,
    InotifyEvent_deleted,
    InotifyEvent_accessed
  };
  return values;
}

inline const char * const *EnumNamesInotifyEvent() {
  static const char * const names[6] = {
    "modified",
    "created",
    "size_reached",
    "deleted",
    "accessed",
    nullptr
  };
  return names;
}

inline const char *EnumNameInotifyEvent(InotifyEvent e) {
  if (::flatbuffers::IsOutRange(e, InotifyEvent_modified, InotifyEvent_accessed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInotifyEvent()[index];
}

enum SocketState : int8_t {
  SocketState_unknown = 0,
  SocketState_created = 1,
  SocketState_listeing = 2,
  SocketState_MIN = SocketState_unknown,
  SocketState_MAX = SocketState_listeing
};

inline const SocketState (&EnumValuesSocketState())[3] {
  static const SocketState values[] = {
    SocketState_unknown,
    SocketState_created,
    SocketState_listeing
  };
  return values;
}

inline const char * const *EnumNamesSocketState() {
  static const char * const names[4] = {
    "unknown",
    "created",
    "listeing",
    nullptr
  };
  return names;
}

inline const char *EnumNameSocketState(SocketState e) {
  if (::flatbuffers::IsOutRange(e, SocketState_unknown, SocketState_listeing)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSocketState()[index];
}

enum Surveillance : uint8_t {
  Surveillance_NONE = 0,
  Surveillance_Inotify = 1,
  Surveillance_TCPSocket = 2,
  Surveillance_MIN = Surveillance_NONE,
  Surveillance_MAX = Surveillance_TCPSocket
};

inline const Surveillance (&EnumValuesSurveillance())[3] {
  static const Surveillance values[] = {
    Surveillance_NONE,
    Surveillance_Inotify,
    Surveillance_TCPSocket
  };
  return values;
}

inline const char * const *EnumNamesSurveillance() {
  static const char * const names[4] = {
    "NONE",
    "Inotify",
    "TCPSocket",
    nullptr
  };
  return names;
}

inline const char *EnumNameSurveillance(Surveillance e) {
  if (::flatbuffers::IsOutRange(e, Surveillance_NONE, Surveillance_TCPSocket)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSurveillance()[index];
}

template<typename T> struct SurveillanceTraits {
  static const Surveillance enum_value = Surveillance_NONE;
};

template<> struct SurveillanceTraits<demon::Inotify> {
  static const Surveillance enum_value = Surveillance_Inotify;
};

template<> struct SurveillanceTraits<demon::TCPSocket> {
  static const Surveillance enum_value = Surveillance_TCPSocket;
};

bool VerifySurveillance(::flatbuffers::Verifier &verifier, const void *obj, Surveillance type);
bool VerifySurveillanceVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

///
/// Main message table
///
enum Event : uint8_t {
  Event_NONE = 0,
  Event_RunCommand = 1,
  Event_KillProcess = 2,
  Event_EstablishTCPConnection = 3,
  Event_EstablishUnixConnection = 4,
  Event_ProcessLaunched = 5,
  Event_ChildCreationError = 6,
  Event_ProcessTerminated = 7,
  Event_TCPSocketListening = 8,
  Event_InotifyPathUpdated = 9,
  Event_InotifyWatchListUpdated = 10,
  Event_SocketWatched = 11,
  Event_SocketWatchTerminated = 12,
  Event_MIN = Event_NONE,
  Event_MAX = Event_SocketWatchTerminated
};

inline const Event (&EnumValuesEvent())[13] {
  static const Event values[] = {
    Event_NONE,
    Event_RunCommand,
    Event_KillProcess,
    Event_EstablishTCPConnection,
    Event_EstablishUnixConnection,
    Event_ProcessLaunched,
    Event_ChildCreationError,
    Event_ProcessTerminated,
    Event_TCPSocketListening,
    Event_InotifyPathUpdated,
    Event_InotifyWatchListUpdated,
    Event_SocketWatched,
    Event_SocketWatchTerminated
  };
  return values;
}

inline const char * const *EnumNamesEvent() {
  static const char * const names[14] = {
    "NONE",
    "RunCommand",
    "KillProcess",
    "EstablishTCPConnection",
    "EstablishUnixConnection",
    "ProcessLaunched",
    "ChildCreationError",
    "ProcessTerminated",
    "TCPSocketListening",
    "InotifyPathUpdated",
    "InotifyWatchListUpdated",
    "SocketWatched",
    "SocketWatchTerminated",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvent(Event e) {
  if (::flatbuffers::IsOutRange(e, Event_NONE, Event_SocketWatchTerminated)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvent()[index];
}

template<typename T> struct EventTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventTraits<demon::RunCommand> {
  static const Event enum_value = Event_RunCommand;
};

template<> struct EventTraits<demon::KillProcess> {
  static const Event enum_value = Event_KillProcess;
};

template<> struct EventTraits<demon::EstablishTCPConnection> {
  static const Event enum_value = Event_EstablishTCPConnection;
};

template<> struct EventTraits<demon::EstablishUnixConnection> {
  static const Event enum_value = Event_EstablishUnixConnection;
};

template<> struct EventTraits<demon::ProcessLaunched> {
  static const Event enum_value = Event_ProcessLaunched;
};

template<> struct EventTraits<demon::ChildCreationError> {
  static const Event enum_value = Event_ChildCreationError;
};

template<> struct EventTraits<demon::ProcessTerminated> {
  static const Event enum_value = Event_ProcessTerminated;
};

template<> struct EventTraits<demon::TCPSocketListening> {
  static const Event enum_value = Event_TCPSocketListening;
};

template<> struct EventTraits<demon::InotifyPathUpdated> {
  static const Event enum_value = Event_InotifyPathUpdated;
};

template<> struct EventTraits<demon::InotifyWatchListUpdated> {
  static const Event enum_value = Event_InotifyWatchListUpdated;
};

template<> struct EventTraits<demon::SocketWatched> {
  static const Event enum_value = Event_SocketWatched;
};

template<> struct EventTraits<demon::SocketWatchTerminated> {
  static const Event enum_value = Event_SocketWatchTerminated;
};

bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type);
bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Inotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InotifyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT_PATHS = 4,
    VT_MASK = 6,
    VT_SIZE = 8
  };
  const ::flatbuffers::String *root_paths() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROOT_PATHS);
  }
  int32_t mask() const {
    return GetField<int32_t>(VT_MASK, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT_PATHS) &&
           verifier.VerifyString(root_paths()) &&
           VerifyField<int32_t>(verifier, VT_MASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct InotifyBuilder {
  typedef Inotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_root_paths(::flatbuffers::Offset<::flatbuffers::String> root_paths) {
    fbb_.AddOffset(Inotify::VT_ROOT_PATHS, root_paths);
  }
  void add_mask(int32_t mask) {
    fbb_.AddElement<int32_t>(Inotify::VT_MASK, mask, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Inotify::VT_SIZE, size, 0);
  }
  explicit InotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Inotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Inotify>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Inotify> CreateInotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> root_paths = 0,
    int32_t mask = 0,
    uint32_t size = 0) {
  InotifyBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_mask(mask);
  builder_.add_root_paths(root_paths);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Inotify> CreateInotifyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *root_paths = nullptr,
    int32_t mask = 0,
    uint32_t size = 0) {
  auto root_paths__ = root_paths ? _fbb.CreateString(root_paths) : 0;
  return demon::CreateInotify(
      _fbb,
      root_paths__,
      mask,
      size);
}

struct TCPSocket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCPSocketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESTPORT = 4
  };
  uint32_t destport() const {
    return GetField<uint32_t>(VT_DESTPORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DESTPORT, 4) &&
           verifier.EndTable();
  }
};

struct TCPSocketBuilder {
  typedef TCPSocket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_destport(uint32_t destport) {
    fbb_.AddElement<uint32_t>(TCPSocket::VT_DESTPORT, destport, 0);
  }
  explicit TCPSocketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCPSocket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCPSocket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCPSocket> CreateTCPSocket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t destport = 0) {
  TCPSocketBuilder builder_(_fbb);
  builder_.add_destport(destport);
  return builder_.Finish();
}

struct SurveillanceEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SurveillanceEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  demon::Surveillance event_type() const {
    return static_cast<demon::Surveillance>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const demon::Inotify *event_as_Inotify() const {
    return event_type() == demon::Surveillance_Inotify ? static_cast<const demon::Inotify *>(event()) : nullptr;
  }
  const demon::TCPSocket *event_as_TCPSocket() const {
    return event_type() == demon::Surveillance_TCPSocket ? static_cast<const demon::TCPSocket *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifySurveillance(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

template<> inline const demon::Inotify *SurveillanceEvent::event_as<demon::Inotify>() const {
  return event_as_Inotify();
}

template<> inline const demon::TCPSocket *SurveillanceEvent::event_as<demon::TCPSocket>() const {
  return event_as_TCPSocket();
}

struct SurveillanceEventBuilder {
  typedef SurveillanceEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(demon::Surveillance event_type) {
    fbb_.AddElement<uint8_t>(SurveillanceEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(SurveillanceEvent::VT_EVENT, event);
  }
  explicit SurveillanceEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SurveillanceEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SurveillanceEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SurveillanceEvent> CreateSurveillanceEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    demon::Surveillance event_type = demon::Surveillance_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  SurveillanceEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

struct RunCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_ARGS = 6,
    VT_ENVP = 8,
    VT_FLAGS = 10,
    VT_STACK_SIZE = 12,
    VT_TO_WATCH = 14
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ARGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *envp() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ENVP);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  uint32_t stack_size() const {
    return GetField<uint32_t>(VT_STACK_SIZE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<demon::SurveillanceEvent>> *to_watch() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<demon::SurveillanceEvent>> *>(VT_TO_WATCH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfStrings(args()) &&
           VerifyOffset(verifier, VT_ENVP) &&
           verifier.VerifyVector(envp()) &&
           verifier.VerifyVectorOfStrings(envp()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint32_t>(verifier, VT_STACK_SIZE, 4) &&
           VerifyOffset(verifier, VT_TO_WATCH) &&
           verifier.VerifyVector(to_watch()) &&
           verifier.VerifyVectorOfTables(to_watch()) &&
           verifier.EndTable();
  }
};

struct RunCommandBuilder {
  typedef RunCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(RunCommand::VT_PATH, path);
  }
  void add_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> args) {
    fbb_.AddOffset(RunCommand::VT_ARGS, args);
  }
  void add_envp(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> envp) {
    fbb_.AddOffset(RunCommand::VT_ENVP, envp);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(RunCommand::VT_FLAGS, flags, 0);
  }
  void add_stack_size(uint32_t stack_size) {
    fbb_.AddElement<uint32_t>(RunCommand::VT_STACK_SIZE, stack_size, 0);
  }
  void add_to_watch(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<demon::SurveillanceEvent>>> to_watch) {
    fbb_.AddOffset(RunCommand::VT_TO_WATCH, to_watch);
  }
  explicit RunCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunCommand> CreateRunCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> args = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> envp = 0,
    uint32_t flags = 0,
    uint32_t stack_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<demon::SurveillanceEvent>>> to_watch = 0) {
  RunCommandBuilder builder_(_fbb);
  builder_.add_to_watch(to_watch);
  builder_.add_stack_size(stack_size);
  builder_.add_flags(flags);
  builder_.add_envp(envp);
  builder_.add_args(args);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RunCommand> CreateRunCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *args = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *envp = nullptr,
    uint32_t flags = 0,
    uint32_t stack_size = 0,
    const std::vector<::flatbuffers::Offset<demon::SurveillanceEvent>> *to_watch = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  auto args__ = args ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*args) : 0;
  auto envp__ = envp ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*envp) : 0;
  auto to_watch__ = to_watch ? _fbb.CreateVector<::flatbuffers::Offset<demon::SurveillanceEvent>>(*to_watch) : 0;
  return demon::CreateRunCommand(
      _fbb,
      path__,
      args__,
      envp__,
      flags,
      stack_size,
      to_watch__);
}

struct KillProcess FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KillProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PID = 4
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID, 4) &&
           verifier.EndTable();
  }
};

struct KillProcessBuilder {
  typedef KillProcess Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(KillProcess::VT_PID, pid, 0);
  }
  explicit KillProcessBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KillProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KillProcess>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KillProcess> CreateKillProcess(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0) {
  KillProcessBuilder builder_(_fbb);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct ProcessLaunched FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessLaunchedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PID = 4
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID, 4) &&
           verifier.EndTable();
  }
};

struct ProcessLaunchedBuilder {
  typedef ProcessLaunched Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessLaunched::VT_PID, pid, 0);
  }
  explicit ProcessLaunchedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessLaunched> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessLaunched>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessLaunched> CreateProcessLaunched(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0) {
  ProcessLaunchedBuilder builder_(_fbb);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct ChildCreationError FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChildCreationErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  uint32_t error_code() const {
    return GetField<uint32_t>(VT_ERROR_CODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ERROR_CODE, 4) &&
           verifier.EndTable();
  }
};

struct ChildCreationErrorBuilder {
  typedef ChildCreationError Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_error_code(uint32_t error_code) {
    fbb_.AddElement<uint32_t>(ChildCreationError::VT_ERROR_CODE, error_code, 0);
  }
  explicit ChildCreationErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChildCreationError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChildCreationError>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChildCreationError> CreateChildCreationError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t error_code = 0) {
  ChildCreationErrorBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct ProcessTerminated FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProcessTerminatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PID = 4,
    VT_ERROR_CODE = 6
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  uint32_t error_code() const {
    return GetField<uint32_t>(VT_ERROR_CODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ERROR_CODE, 4) &&
           verifier.EndTable();
  }
};

struct ProcessTerminatedBuilder {
  typedef ProcessTerminated Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessTerminated::VT_PID, pid, 0);
  }
  void add_error_code(uint32_t error_code) {
    fbb_.AddElement<uint32_t>(ProcessTerminated::VT_ERROR_CODE, error_code, 0);
  }
  explicit ProcessTerminatedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProcessTerminated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProcessTerminated>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProcessTerminated> CreateProcessTerminated(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    uint32_t error_code = 0) {
  ProcessTerminatedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct TCPSocketListening FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCPSocketListeningBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4
  };
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_PORT, 2) &&
           verifier.EndTable();
  }
};

struct TCPSocketListeningBuilder {
  typedef TCPSocketListening Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(TCPSocketListening::VT_PORT, port, 0);
  }
  explicit TCPSocketListeningBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCPSocketListening> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCPSocketListening>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCPSocketListening> CreateTCPSocketListening(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t port = 0) {
  TCPSocketListeningBuilder builder_(_fbb);
  builder_.add_port(port);
  return builder_.Finish();
}

struct InotifyPathUpdated FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InotifyPathUpdatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_TRIGGER_EVENTS = 6,
    VT_SIZE = 8,
    VT_SIZE_LIMIT = 10
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  demon::InotifyEvent trigger_events() const {
    return static_cast<demon::InotifyEvent>(GetField<int8_t>(VT_TRIGGER_EVENTS, 0));
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t size_limit() const {
    return GetField<uint32_t>(VT_SIZE_LIMIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<int8_t>(verifier, VT_TRIGGER_EVENTS, 1) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_LIMIT, 4) &&
           verifier.EndTable();
  }
};

struct InotifyPathUpdatedBuilder {
  typedef InotifyPathUpdated Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(InotifyPathUpdated::VT_PATH, path);
  }
  void add_trigger_events(demon::InotifyEvent trigger_events) {
    fbb_.AddElement<int8_t>(InotifyPathUpdated::VT_TRIGGER_EVENTS, static_cast<int8_t>(trigger_events), 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(InotifyPathUpdated::VT_SIZE, size, 0);
  }
  void add_size_limit(uint32_t size_limit) {
    fbb_.AddElement<uint32_t>(InotifyPathUpdated::VT_SIZE_LIMIT, size_limit, 0);
  }
  explicit InotifyPathUpdatedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InotifyPathUpdated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InotifyPathUpdated>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InotifyPathUpdated> CreateInotifyPathUpdated(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    demon::InotifyEvent trigger_events = demon::InotifyEvent_modified,
    uint32_t size = 0,
    uint32_t size_limit = 0) {
  InotifyPathUpdatedBuilder builder_(_fbb);
  builder_.add_size_limit(size_limit);
  builder_.add_size(size);
  builder_.add_path(path);
  builder_.add_trigger_events(trigger_events);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InotifyPathUpdated> CreateInotifyPathUpdatedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    demon::InotifyEvent trigger_events = demon::InotifyEvent_modified,
    uint32_t size = 0,
    uint32_t size_limit = 0) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return demon::CreateInotifyPathUpdated(
      _fbb,
      path__,
      trigger_events,
      size,
      size_limit);
}

struct InotifyWatchListUpdated FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InotifyWatchListUpdatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct InotifyWatchListUpdatedBuilder {
  typedef InotifyWatchListUpdated Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(InotifyWatchListUpdated::VT_PATH, path);
  }
  explicit InotifyWatchListUpdatedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InotifyWatchListUpdated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InotifyWatchListUpdated>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InotifyWatchListUpdated> CreateInotifyWatchListUpdated(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  InotifyWatchListUpdatedBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InotifyWatchListUpdated> CreateInotifyWatchListUpdatedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return demon::CreateInotifyWatchListUpdated(
      _fbb,
      path__);
}

struct SocketWatched FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SocketWatchedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4
  };
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           verifier.EndTable();
  }
};

struct SocketWatchedBuilder {
  typedef SocketWatched Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(SocketWatched::VT_PORT, port, 0);
  }
  explicit SocketWatchedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SocketWatched> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SocketWatched>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SocketWatched> CreateSocketWatched(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t port = 0) {
  SocketWatchedBuilder builder_(_fbb);
  builder_.add_port(port);
  return builder_.Finish();
}

struct SocketWatchTerminated FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SocketWatchTerminatedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_STATE = 6
  };
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  demon::SocketState state() const {
    return static_cast<demon::SocketState>(GetField<int8_t>(VT_STATE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           verifier.EndTable();
  }
};

struct SocketWatchTerminatedBuilder {
  typedef SocketWatchTerminated Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(SocketWatchTerminated::VT_PORT, port, 0);
  }
  void add_state(demon::SocketState state) {
    fbb_.AddElement<int8_t>(SocketWatchTerminated::VT_STATE, static_cast<int8_t>(state), 0);
  }
  explicit SocketWatchTerminatedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SocketWatchTerminated> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SocketWatchTerminated>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SocketWatchTerminated> CreateSocketWatchTerminated(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t port = 0,
    demon::SocketState state = demon::SocketState_unknown) {
  SocketWatchTerminatedBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_state(state);
  return builder_.Finish();
}

struct EstablishTCPConnection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EstablishTCPConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESTPORT = 4
  };
  uint32_t destport() const {
    return GetField<uint32_t>(VT_DESTPORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DESTPORT, 4) &&
           verifier.EndTable();
  }
};

struct EstablishTCPConnectionBuilder {
  typedef EstablishTCPConnection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_destport(uint32_t destport) {
    fbb_.AddElement<uint32_t>(EstablishTCPConnection::VT_DESTPORT, destport, 0);
  }
  explicit EstablishTCPConnectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EstablishTCPConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EstablishTCPConnection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EstablishTCPConnection> CreateEstablishTCPConnection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t destport = 0) {
  EstablishTCPConnectionBuilder builder_(_fbb);
  builder_.add_destport(destport);
  return builder_.Finish();
}

struct EstablishUnixConnection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EstablishUnixConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct EstablishUnixConnectionBuilder {
  typedef EstablishUnixConnection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(EstablishUnixConnection::VT_PATH, path);
  }
  explicit EstablishUnixConnectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EstablishUnixConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EstablishUnixConnection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EstablishUnixConnection> CreateEstablishUnixConnection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  EstablishUnixConnectionBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EstablishUnixConnection> CreateEstablishUnixConnectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return demon::CreateEstablishUnixConnection(
      _fbb,
      path__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENTS_TYPE = 4,
    VT_EVENTS = 6
  };
  demon::Event events_type() const {
    return static_cast<demon::Event>(GetField<uint8_t>(VT_EVENTS_TYPE, 0));
  }
  const void *events() const {
    return GetPointer<const void *>(VT_EVENTS);
  }
  template<typename T> const T *events_as() const;
  const demon::RunCommand *events_as_RunCommand() const {
    return events_type() == demon::Event_RunCommand ? static_cast<const demon::RunCommand *>(events()) : nullptr;
  }
  const demon::KillProcess *events_as_KillProcess() const {
    return events_type() == demon::Event_KillProcess ? static_cast<const demon::KillProcess *>(events()) : nullptr;
  }
  const demon::EstablishTCPConnection *events_as_EstablishTCPConnection() const {
    return events_type() == demon::Event_EstablishTCPConnection ? static_cast<const demon::EstablishTCPConnection *>(events()) : nullptr;
  }
  const demon::EstablishUnixConnection *events_as_EstablishUnixConnection() const {
    return events_type() == demon::Event_EstablishUnixConnection ? static_cast<const demon::EstablishUnixConnection *>(events()) : nullptr;
  }
  const demon::ProcessLaunched *events_as_ProcessLaunched() const {
    return events_type() == demon::Event_ProcessLaunched ? static_cast<const demon::ProcessLaunched *>(events()) : nullptr;
  }
  const demon::ChildCreationError *events_as_ChildCreationError() const {
    return events_type() == demon::Event_ChildCreationError ? static_cast<const demon::ChildCreationError *>(events()) : nullptr;
  }
  const demon::ProcessTerminated *events_as_ProcessTerminated() const {
    return events_type() == demon::Event_ProcessTerminated ? static_cast<const demon::ProcessTerminated *>(events()) : nullptr;
  }
  const demon::TCPSocketListening *events_as_TCPSocketListening() const {
    return events_type() == demon::Event_TCPSocketListening ? static_cast<const demon::TCPSocketListening *>(events()) : nullptr;
  }
  const demon::InotifyPathUpdated *events_as_InotifyPathUpdated() const {
    return events_type() == demon::Event_InotifyPathUpdated ? static_cast<const demon::InotifyPathUpdated *>(events()) : nullptr;
  }
  const demon::InotifyWatchListUpdated *events_as_InotifyWatchListUpdated() const {
    return events_type() == demon::Event_InotifyWatchListUpdated ? static_cast<const demon::InotifyWatchListUpdated *>(events()) : nullptr;
  }
  const demon::SocketWatched *events_as_SocketWatched() const {
    return events_type() == demon::Event_SocketWatched ? static_cast<const demon::SocketWatched *>(events()) : nullptr;
  }
  const demon::SocketWatchTerminated *events_as_SocketWatchTerminated() const {
    return events_type() == demon::Event_SocketWatchTerminated ? static_cast<const demon::SocketWatchTerminated *>(events()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENTS_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENTS) &&
           VerifyEvent(verifier, events(), events_type()) &&
           verifier.EndTable();
  }
};

template<> inline const demon::RunCommand *Message::events_as<demon::RunCommand>() const {
  return events_as_RunCommand();
}

template<> inline const demon::KillProcess *Message::events_as<demon::KillProcess>() const {
  return events_as_KillProcess();
}

template<> inline const demon::EstablishTCPConnection *Message::events_as<demon::EstablishTCPConnection>() const {
  return events_as_EstablishTCPConnection();
}

template<> inline const demon::EstablishUnixConnection *Message::events_as<demon::EstablishUnixConnection>() const {
  return events_as_EstablishUnixConnection();
}

template<> inline const demon::ProcessLaunched *Message::events_as<demon::ProcessLaunched>() const {
  return events_as_ProcessLaunched();
}

template<> inline const demon::ChildCreationError *Message::events_as<demon::ChildCreationError>() const {
  return events_as_ChildCreationError();
}

template<> inline const demon::ProcessTerminated *Message::events_as<demon::ProcessTerminated>() const {
  return events_as_ProcessTerminated();
}

template<> inline const demon::TCPSocketListening *Message::events_as<demon::TCPSocketListening>() const {
  return events_as_TCPSocketListening();
}

template<> inline const demon::InotifyPathUpdated *Message::events_as<demon::InotifyPathUpdated>() const {
  return events_as_InotifyPathUpdated();
}

template<> inline const demon::InotifyWatchListUpdated *Message::events_as<demon::InotifyWatchListUpdated>() const {
  return events_as_InotifyWatchListUpdated();
}

template<> inline const demon::SocketWatched *Message::events_as<demon::SocketWatched>() const {
  return events_as_SocketWatched();
}

template<> inline const demon::SocketWatchTerminated *Message::events_as<demon::SocketWatchTerminated>() const {
  return events_as_SocketWatchTerminated();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_events_type(demon::Event events_type) {
    fbb_.AddElement<uint8_t>(Message::VT_EVENTS_TYPE, static_cast<uint8_t>(events_type), 0);
  }
  void add_events(::flatbuffers::Offset<void> events) {
    fbb_.AddOffset(Message::VT_EVENTS, events);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    demon::Event events_type = demon::Event_NONE,
    ::flatbuffers::Offset<void> events = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_events(events);
  builder_.add_events_type(events_type);
  return builder_.Finish();
}

inline bool VerifySurveillance(::flatbuffers::Verifier &verifier, const void *obj, Surveillance type) {
  switch (type) {
    case Surveillance_NONE: {
      return true;
    }
    case Surveillance_Inotify: {
      auto ptr = reinterpret_cast<const demon::Inotify *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Surveillance_TCPSocket: {
      auto ptr = reinterpret_cast<const demon::TCPSocket *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySurveillanceVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySurveillance(
        verifier,  values->Get(i), types->GetEnum<Surveillance>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type) {
  switch (type) {
    case Event_NONE: {
      return true;
    }
    case Event_RunCommand: {
      auto ptr = reinterpret_cast<const demon::RunCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_KillProcess: {
      auto ptr = reinterpret_cast<const demon::KillProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_EstablishTCPConnection: {
      auto ptr = reinterpret_cast<const demon::EstablishTCPConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_EstablishUnixConnection: {
      auto ptr = reinterpret_cast<const demon::EstablishUnixConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ProcessLaunched: {
      auto ptr = reinterpret_cast<const demon::ProcessLaunched *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ChildCreationError: {
      auto ptr = reinterpret_cast<const demon::ChildCreationError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ProcessTerminated: {
      auto ptr = reinterpret_cast<const demon::ProcessTerminated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_TCPSocketListening: {
      auto ptr = reinterpret_cast<const demon::TCPSocketListening *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_InotifyPathUpdated: {
      auto ptr = reinterpret_cast<const demon::InotifyPathUpdated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_InotifyWatchListUpdated: {
      auto ptr = reinterpret_cast<const demon::InotifyWatchListUpdated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_SocketWatched: {
      auto ptr = reinterpret_cast<const demon::SocketWatched *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_SocketWatchTerminated: {
      auto ptr = reinterpret_cast<const demon::SocketWatchTerminated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvent(
        verifier,  values->Get(i), types->GetEnum<Event>(i))) {
      return false;
    }
  }
  return true;
}

inline const demon::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<demon::Message>(buf);
}

inline const demon::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<demon::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<demon::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<demon::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<demon::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<demon::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace demon

#endif  // FLATBUFFERS_GENERATED_DEMON_DEMON_H_

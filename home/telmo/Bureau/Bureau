use std::thread;

async fn trace_process(pid: Pid) {
    // Attendre que le processus soit prêt
    match waitpid(pid, None) {
        Ok(WaitStatus::Stopped(_, _)) => println!("Processus arrêté, prêt pour le traçage"),
        _ => {
            eprintln!("Le processus n'est pas dans l'état attendu");
            return;
        }
    }

    loop {
        if let Err(e) = ptrace::syscall(pid, None) {
            eprintln!("Erreur lors de l'appel à ptrace::syscall: {}", e);
            break;
        }

        match waitpid(pid, None) {
            Ok(WaitStatus::Stopped(_, sig)) => {
                if sig & 0x80 != 0 {
                    if let Ok(regs) = ptrace::getregs(pid) {
                        let syscall_number = regs.orig_rax;
                        if syscall_number == SYS_socket as u64 {
                            println!("[PID {}] socket() détecté !", pid);
                        } else if syscall_number == SYS_connect as u64 {
                            println!("[PID {}] connect() détecté !", pid);
                        }
                    }
                }
            }
            Ok(WaitStatus::Exited(_, _)) => {
                println!("Le processus {} s'est terminé", pid);
                break;
            }
            Err(e) => {
                eprintln!("Erreur lors de l'attente du processus {}: {}", pid, e);
                break;
            }
            _ => {}
        }
    }
}

unsafe fn start_target_process(command: &str) -> Pid {
    let child = Command::new(command)
        .pre_exec(|| {
            ptrace::traceme().unwrap();
            Ok(())
        })
        .spawn()
        .expect("Impossible de lancer le processus");
    
    let pid = Pid::from_raw(child.id() as i32);
    
    // Attendre que le processus soit arrêté
    waitpid(pid, None).expect("Impossible d'attendre le processus enfant");
    
    pid
}

async unsafe fn launch_trace_process(target: &str) -> Result<(), Box<dyn std::error::Error>> {
    let pid = start_target_process(&target);
    println!("Attachement à PID {}...", pid);

    ptrace::setoptions(pid, nix::sys::ptrace::Options::PTRACE_O_TRACESYSGOOD)?;

    // Continuer l'exécution du processus
    ptrace::cont(pid, None)?;

    task::spawn(async move {
        trace_process(pid).await;
    });

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    unsafe {
        launch_trace_process("/home/telmo/Bureau/Bureau d'étude/Code/rust-proc-ctrld/rust/target/debug/Start_TCP_socket").await?;
    }

    // Attendre un peu plus longtemps pour s'assurer que le processus est bien démarré
    tokio::time::sleep(time::Duration::from_secs(5)).await;

    // ... (le reste du code reste inchangé)
}
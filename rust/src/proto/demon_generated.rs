// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod demon {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INOTIFY_EVENT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INOTIFY_EVENT: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INOTIFY_EVENT: [InotifyEvent; 5] = [
  InotifyEvent::modification,
  InotifyEvent::creation,
  InotifyEvent::size,
  InotifyEvent::deletion,
  InotifyEvent::access,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InotifyEvent(pub i8);
#[allow(non_upper_case_globals)]
impl InotifyEvent {
  pub const modification: Self = Self(0);
  pub const creation: Self = Self(1);
  pub const size: Self = Self(2);
  pub const deletion: Self = Self(3);
  pub const access: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::modification,
    Self::creation,
    Self::size,
    Self::deletion,
    Self::access,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::modification => Some("modification"),
      Self::creation => Some("creation"),
      Self::size => Some("size"),
      Self::deletion => Some("deletion"),
      Self::access => Some("access"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for InotifyEvent {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InotifyEvent {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for InotifyEvent {
    type Output = InotifyEvent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for InotifyEvent {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InotifyEvent {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InotifyEvent {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SURVEILLANCE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SURVEILLANCE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SURVEILLANCE: [Surveillance; 3] = [
  Surveillance::NONE,
  Surveillance::inotify,
  Surveillance::tcp_socket,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Surveillance(pub u8);
#[allow(non_upper_case_globals)]
impl Surveillance {
  pub const NONE: Self = Self(0);
  pub const inotify: Self = Self(1);
  pub const tcp_socket: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::inotify,
    Self::tcp_socket,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::inotify => Some("inotify"),
      Self::tcp_socket => Some("tcp_socket"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Surveillance {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Surveillance {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Surveillance {
    type Output = Surveillance;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Surveillance {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Surveillance {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Surveillance {}
pub struct SurveillanceUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EVENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EVENT: u8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT: [Event; 10] = [
  Event::NONE,
  Event::run_command,
  Event::kill_process,
  Event::establish_tcp_connection,
  Event::establish_unix_connection,
  Event::process_launched,
  Event::child_creation_error,
  Event::process_terminated,
  Event::tcp_socket_listening,
  Event::inotify_path_updated,
];

///
/// Main message table
///
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Event(pub u8);
#[allow(non_upper_case_globals)]
impl Event {
  pub const NONE: Self = Self(0);
  pub const run_command: Self = Self(1);
  pub const kill_process: Self = Self(2);
  pub const establish_tcp_connection: Self = Self(3);
  pub const establish_unix_connection: Self = Self(4);
  pub const process_launched: Self = Self(5);
  pub const child_creation_error: Self = Self(6);
  pub const process_terminated: Self = Self(7);
  pub const tcp_socket_listening: Self = Self(8);
  pub const inotify_path_updated: Self = Self(9);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::run_command,
    Self::kill_process,
    Self::establish_tcp_connection,
    Self::establish_unix_connection,
    Self::process_launched,
    Self::child_creation_error,
    Self::process_terminated,
    Self::tcp_socket_listening,
    Self::inotify_path_updated,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::run_command => Some("run_command"),
      Self::kill_process => Some("kill_process"),
      Self::establish_tcp_connection => Some("establish_tcp_connection"),
      Self::establish_unix_connection => Some("establish_unix_connection"),
      Self::process_launched => Some("process_launched"),
      Self::child_creation_error => Some("child_creation_error"),
      Self::process_terminated => Some("process_terminated"),
      Self::tcp_socket_listening => Some("tcp_socket_listening"),
      Self::inotify_path_updated => Some("inotify_path_updated"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Event {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Event {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Event {
    type Output = Event;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Event {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Event {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Event {}
pub struct EventUnionTableOffset {}

pub enum SizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Size<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Size<'a> {
  type Inner = Size<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Size<'a> {
  pub const VT_SIZE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Size { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SizeArgs
  ) -> flatbuffers::WIPOffset<Size<'bldr>> {
    let mut builder = SizeBuilder::new(_fbb);
    builder.add_size(args.size);
    builder.finish()
  }


  #[inline]
  pub fn size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Size::VT_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Size<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("size", Self::VT_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct SizeArgs {
    pub size: i32,
}
impl<'a> Default for SizeArgs {
  #[inline]
  fn default() -> Self {
    SizeArgs {
      size: 0,
    }
  }
}

pub struct SizeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SizeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_size(&mut self, size: i32) {
    self.fbb_.push_slot::<i32>(Size::VT_SIZE, size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SizeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SizeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Size<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Size<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Size");
      ds.field("size", &self.size());
      ds.finish()
  }
}
pub enum InotifyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Inotify<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Inotify<'a> {
  type Inner = Inotify<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Inotify<'a> {
  pub const VT_ROOT_PATHS: flatbuffers::VOffsetT = 4;
  pub const VT_TRIGGER_EVENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Inotify { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InotifyArgs<'args>
  ) -> flatbuffers::WIPOffset<Inotify<'bldr>> {
    let mut builder = InotifyBuilder::new(_fbb);
    if let Some(x) = args.trigger_events { builder.add_trigger_events(x); }
    if let Some(x) = args.root_paths { builder.add_root_paths(x); }
    builder.finish()
  }


  #[inline]
  pub fn root_paths(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Inotify::VT_ROOT_PATHS, None)}
  }
  #[inline]
  pub fn trigger_events(&self) -> Option<flatbuffers::Vector<'a, InotifyEvent>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, InotifyEvent>>>(Inotify::VT_TRIGGER_EVENTS, None)}
  }
}

impl flatbuffers::Verifiable for Inotify<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("root_paths", Self::VT_ROOT_PATHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, InotifyEvent>>>("trigger_events", Self::VT_TRIGGER_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct InotifyArgs<'a> {
    pub root_paths: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trigger_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, InotifyEvent>>>,
}
impl<'a> Default for InotifyArgs<'a> {
  #[inline]
  fn default() -> Self {
    InotifyArgs {
      root_paths: None,
      trigger_events: None,
    }
  }
}

pub struct InotifyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InotifyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_root_paths(&mut self, root_paths: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Inotify::VT_ROOT_PATHS, root_paths);
  }
  #[inline]
  pub fn add_trigger_events(&mut self, trigger_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , InotifyEvent>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Inotify::VT_TRIGGER_EVENTS, trigger_events);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InotifyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InotifyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Inotify<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Inotify<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Inotify");
      ds.field("root_paths", &self.root_paths());
      ds.field("trigger_events", &self.trigger_events());
      ds.finish()
  }
}
pub enum TCPSocketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TCPSocket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TCPSocket<'a> {
  type Inner = TCPSocket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TCPSocket<'a> {
  pub const VT_DESTPORT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TCPSocket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TCPSocketArgs
  ) -> flatbuffers::WIPOffset<TCPSocket<'bldr>> {
    let mut builder = TCPSocketBuilder::new(_fbb);
    builder.add_destport(args.destport);
    builder.finish()
  }


  #[inline]
  pub fn destport(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TCPSocket::VT_DESTPORT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TCPSocket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("destport", Self::VT_DESTPORT, false)?
     .finish();
    Ok(())
  }
}
pub struct TCPSocketArgs {
    pub destport: i32,
}
impl<'a> Default for TCPSocketArgs {
  #[inline]
  fn default() -> Self {
    TCPSocketArgs {
      destport: 0,
    }
  }
}

pub struct TCPSocketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TCPSocketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_destport(&mut self, destport: i32) {
    self.fbb_.push_slot::<i32>(TCPSocket::VT_DESTPORT, destport, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TCPSocketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TCPSocketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TCPSocket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TCPSocket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TCPSocket");
      ds.field("destport", &self.destport());
      ds.finish()
  }
}
pub enum SurveillanceEventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SurveillanceEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SurveillanceEvent<'a> {
  type Inner = SurveillanceEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SurveillanceEvent<'a> {
  pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SurveillanceEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SurveillanceEventArgs
  ) -> flatbuffers::WIPOffset<SurveillanceEvent<'bldr>> {
    let mut builder = SurveillanceEventBuilder::new(_fbb);
    if let Some(x) = args.event { builder.add_event(x); }
    builder.add_event_type(args.event_type);
    builder.finish()
  }


  #[inline]
  pub fn event_type(&self) -> Surveillance {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Surveillance>(SurveillanceEvent::VT_EVENT_TYPE, Some(Surveillance::NONE)).unwrap()}
  }
  #[inline]
  pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SurveillanceEvent::VT_EVENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_inotify(&self) -> Option<Inotify<'a>> {
    if self.event_type() == Surveillance::inotify {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Inotify::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn event_as_tcp_socket(&self) -> Option<TCPSocket<'a>> {
    if self.event_type() == Surveillance::tcp_socket {
      self.event().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TCPSocket::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for SurveillanceEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Surveillance, _>("event_type", Self::VT_EVENT_TYPE, "event", Self::VT_EVENT, false, |key, v, pos| {
        match key {
          Surveillance::inotify => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Inotify>>("Surveillance::inotify", pos),
          Surveillance::tcp_socket => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TCPSocket>>("Surveillance::tcp_socket", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct SurveillanceEventArgs {
    pub event_type: Surveillance,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SurveillanceEventArgs {
  #[inline]
  fn default() -> Self {
    SurveillanceEventArgs {
      event_type: Surveillance::NONE,
      event: None,
    }
  }
}

pub struct SurveillanceEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SurveillanceEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_event_type(&mut self, event_type: Surveillance) {
    self.fbb_.push_slot::<Surveillance>(SurveillanceEvent::VT_EVENT_TYPE, event_type, Surveillance::NONE);
  }
  #[inline]
  pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SurveillanceEvent::VT_EVENT, event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SurveillanceEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SurveillanceEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SurveillanceEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SurveillanceEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SurveillanceEvent");
      ds.field("event_type", &self.event_type());
      match self.event_type() {
        Surveillance::inotify => {
          if let Some(x) = self.event_as_inotify() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Surveillance::tcp_socket => {
          if let Some(x) = self.event_as_tcp_socket() {
            ds.field("event", &x)
          } else {
            ds.field("event", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("event", &x)
        },
      };
      ds.finish()
  }
}
pub enum RunCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RunCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunCommand<'a> {
  type Inner = RunCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RunCommand<'a> {
  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_ARGS: flatbuffers::VOffsetT = 6;
  pub const VT_ENVP: flatbuffers::VOffsetT = 8;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 10;
  pub const VT_STACK_SIZE: flatbuffers::VOffsetT = 12;
  pub const VT_TO_WATCH: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RunCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RunCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<RunCommand<'bldr>> {
    let mut builder = RunCommandBuilder::new(_fbb);
    if let Some(x) = args.to_watch { builder.add_to_watch(x); }
    builder.add_stack_size(args.stack_size);
    builder.add_flags(args.flags);
    if let Some(x) = args.envp { builder.add_envp(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.path { builder.add_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RunCommand::VT_PATH, None)}
  }
  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RunCommand::VT_ARGS, None)}
  }
  #[inline]
  pub fn envp(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RunCommand::VT_ENVP, None)}
  }
  #[inline]
  pub fn flags(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RunCommand::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stack_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RunCommand::VT_STACK_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn to_watch(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SurveillanceEvent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SurveillanceEvent>>>>(RunCommand::VT_TO_WATCH, None)}
  }
}

impl flatbuffers::Verifiable for RunCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("envp", Self::VT_ENVP, false)?
     .visit_field::<i32>("flags", Self::VT_FLAGS, false)?
     .visit_field::<i32>("stack_size", Self::VT_STACK_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SurveillanceEvent>>>>("to_watch", Self::VT_TO_WATCH, false)?
     .finish();
    Ok(())
  }
}
pub struct RunCommandArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub envp: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub flags: i32,
    pub stack_size: i32,
    pub to_watch: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SurveillanceEvent<'a>>>>>,
}
impl<'a> Default for RunCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    RunCommandArgs {
      path: None,
      args: None,
      envp: None,
      flags: 0,
      stack_size: 0,
      to_watch: None,
    }
  }
}

pub struct RunCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RunCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RunCommand::VT_PATH, path);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RunCommand::VT_ARGS, args);
  }
  #[inline]
  pub fn add_envp(&mut self, envp: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RunCommand::VT_ENVP, envp);
  }
  #[inline]
  pub fn add_flags(&mut self, flags: i32) {
    self.fbb_.push_slot::<i32>(RunCommand::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_stack_size(&mut self, stack_size: i32) {
    self.fbb_.push_slot::<i32>(RunCommand::VT_STACK_SIZE, stack_size, 0);
  }
  #[inline]
  pub fn add_to_watch(&mut self, to_watch: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SurveillanceEvent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RunCommand::VT_TO_WATCH, to_watch);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RunCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RunCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RunCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RunCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RunCommand");
      ds.field("path", &self.path());
      ds.field("args", &self.args());
      ds.field("envp", &self.envp());
      ds.field("flags", &self.flags());
      ds.field("stack_size", &self.stack_size());
      ds.field("to_watch", &self.to_watch());
      ds.finish()
  }
}
pub enum KillProcessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KillProcess<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KillProcess<'a> {
  type Inner = KillProcess<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KillProcess<'a> {
  pub const VT_PID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KillProcess { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KillProcessArgs
  ) -> flatbuffers::WIPOffset<KillProcess<'bldr>> {
    let mut builder = KillProcessBuilder::new(_fbb);
    builder.add_pid(args.pid);
    builder.finish()
  }


  #[inline]
  pub fn pid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(KillProcess::VT_PID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KillProcess<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("pid", Self::VT_PID, false)?
     .finish();
    Ok(())
  }
}
pub struct KillProcessArgs {
    pub pid: i32,
}
impl<'a> Default for KillProcessArgs {
  #[inline]
  fn default() -> Self {
    KillProcessArgs {
      pid: 0,
    }
  }
}

pub struct KillProcessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KillProcessBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pid(&mut self, pid: i32) {
    self.fbb_.push_slot::<i32>(KillProcess::VT_PID, pid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KillProcessBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KillProcessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KillProcess<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KillProcess<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KillProcess");
      ds.field("pid", &self.pid());
      ds.finish()
  }
}
pub enum ProcessLaunchedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProcessLaunched<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProcessLaunched<'a> {
  type Inner = ProcessLaunched<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProcessLaunched<'a> {
  pub const VT_PID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProcessLaunched { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProcessLaunchedArgs
  ) -> flatbuffers::WIPOffset<ProcessLaunched<'bldr>> {
    let mut builder = ProcessLaunchedBuilder::new(_fbb);
    builder.add_pid(args.pid);
    builder.finish()
  }


  #[inline]
  pub fn pid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ProcessLaunched::VT_PID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProcessLaunched<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("pid", Self::VT_PID, false)?
     .finish();
    Ok(())
  }
}
pub struct ProcessLaunchedArgs {
    pub pid: i32,
}
impl<'a> Default for ProcessLaunchedArgs {
  #[inline]
  fn default() -> Self {
    ProcessLaunchedArgs {
      pid: 0,
    }
  }
}

pub struct ProcessLaunchedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProcessLaunchedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pid(&mut self, pid: i32) {
    self.fbb_.push_slot::<i32>(ProcessLaunched::VT_PID, pid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProcessLaunchedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProcessLaunchedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProcessLaunched<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProcessLaunched<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProcessLaunched");
      ds.field("pid", &self.pid());
      ds.finish()
  }
}
pub enum ChildCreationErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ChildCreationError<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChildCreationError<'a> {
  type Inner = ChildCreationError<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ChildCreationError<'a> {
  pub const VT_ERRNO: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ChildCreationError { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ChildCreationErrorArgs
  ) -> flatbuffers::WIPOffset<ChildCreationError<'bldr>> {
    let mut builder = ChildCreationErrorBuilder::new(_fbb);
    builder.add_errno(args.errno);
    builder.finish()
  }


  #[inline]
  pub fn errno(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ChildCreationError::VT_ERRNO, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ChildCreationError<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("errno", Self::VT_ERRNO, false)?
     .finish();
    Ok(())
  }
}
pub struct ChildCreationErrorArgs {
    pub errno: i32,
}
impl<'a> Default for ChildCreationErrorArgs {
  #[inline]
  fn default() -> Self {
    ChildCreationErrorArgs {
      errno: 0,
    }
  }
}

pub struct ChildCreationErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChildCreationErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_errno(&mut self, errno: i32) {
    self.fbb_.push_slot::<i32>(ChildCreationError::VT_ERRNO, errno, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ChildCreationErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ChildCreationErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChildCreationError<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ChildCreationError<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ChildCreationError");
      ds.field("errno", &self.errno());
      ds.finish()
  }
}
pub enum ProcessTerminatedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProcessTerminated<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProcessTerminated<'a> {
  type Inner = ProcessTerminated<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProcessTerminated<'a> {
  pub const VT_PID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProcessTerminated { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProcessTerminatedArgs
  ) -> flatbuffers::WIPOffset<ProcessTerminated<'bldr>> {
    let mut builder = ProcessTerminatedBuilder::new(_fbb);
    builder.add_pid(args.pid);
    builder.finish()
  }


  #[inline]
  pub fn pid(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ProcessTerminated::VT_PID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProcessTerminated<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("pid", Self::VT_PID, false)?
     .finish();
    Ok(())
  }
}
pub struct ProcessTerminatedArgs {
    pub pid: i32,
}
impl<'a> Default for ProcessTerminatedArgs {
  #[inline]
  fn default() -> Self {
    ProcessTerminatedArgs {
      pid: 0,
    }
  }
}

pub struct ProcessTerminatedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProcessTerminatedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_pid(&mut self, pid: i32) {
    self.fbb_.push_slot::<i32>(ProcessTerminated::VT_PID, pid, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProcessTerminatedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProcessTerminatedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProcessTerminated<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProcessTerminated<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProcessTerminated");
      ds.field("pid", &self.pid());
      ds.finish()
  }
}
pub enum TCPSocketListeningOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TCPSocketListening<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TCPSocketListening<'a> {
  type Inner = TCPSocketListening<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TCPSocketListening<'a> {
  pub const VT_PORT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TCPSocketListening { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TCPSocketListeningArgs
  ) -> flatbuffers::WIPOffset<TCPSocketListening<'bldr>> {
    let mut builder = TCPSocketListeningBuilder::new(_fbb);
    builder.add_port(args.port);
    builder.finish()
  }


  #[inline]
  pub fn port(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TCPSocketListening::VT_PORT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TCPSocketListening<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("port", Self::VT_PORT, false)?
     .finish();
    Ok(())
  }
}
pub struct TCPSocketListeningArgs {
    pub port: i32,
}
impl<'a> Default for TCPSocketListeningArgs {
  #[inline]
  fn default() -> Self {
    TCPSocketListeningArgs {
      port: 0,
    }
  }
}

pub struct TCPSocketListeningBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TCPSocketListeningBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_port(&mut self, port: i32) {
    self.fbb_.push_slot::<i32>(TCPSocketListening::VT_PORT, port, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TCPSocketListeningBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TCPSocketListeningBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TCPSocketListening<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TCPSocketListening<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TCPSocketListening");
      ds.field("port", &self.port());
      ds.finish()
  }
}
pub enum InotifyPathUpdatedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InotifyPathUpdated<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InotifyPathUpdated<'a> {
  type Inner = InotifyPathUpdated<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> InotifyPathUpdated<'a> {
  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_TRIGGER_EVENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    InotifyPathUpdated { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InotifyPathUpdatedArgs<'args>
  ) -> flatbuffers::WIPOffset<InotifyPathUpdated<'bldr>> {
    let mut builder = InotifyPathUpdatedBuilder::new(_fbb);
    if let Some(x) = args.trigger_events { builder.add_trigger_events(x); }
    if let Some(x) = args.path { builder.add_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(InotifyPathUpdated::VT_PATH, None)}
  }
  #[inline]
  pub fn trigger_events(&self) -> Option<flatbuffers::Vector<'a, InotifyEvent>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, InotifyEvent>>>(InotifyPathUpdated::VT_TRIGGER_EVENTS, None)}
  }
}

impl flatbuffers::Verifiable for InotifyPathUpdated<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, InotifyEvent>>>("trigger_events", Self::VT_TRIGGER_EVENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct InotifyPathUpdatedArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trigger_events: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, InotifyEvent>>>,
}
impl<'a> Default for InotifyPathUpdatedArgs<'a> {
  #[inline]
  fn default() -> Self {
    InotifyPathUpdatedArgs {
      path: None,
      trigger_events: None,
    }
  }
}

pub struct InotifyPathUpdatedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InotifyPathUpdatedBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InotifyPathUpdated::VT_PATH, path);
  }
  #[inline]
  pub fn add_trigger_events(&mut self, trigger_events: flatbuffers::WIPOffset<flatbuffers::Vector<'b , InotifyEvent>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InotifyPathUpdated::VT_TRIGGER_EVENTS, trigger_events);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InotifyPathUpdatedBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InotifyPathUpdatedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InotifyPathUpdated<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for InotifyPathUpdated<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("InotifyPathUpdated");
      ds.field("path", &self.path());
      ds.field("trigger_events", &self.trigger_events());
      ds.finish()
  }
}
pub enum EstablishTCPConnectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EstablishTCPConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EstablishTCPConnection<'a> {
  type Inner = EstablishTCPConnection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EstablishTCPConnection<'a> {
  pub const VT_DESTPORT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EstablishTCPConnection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EstablishTCPConnectionArgs
  ) -> flatbuffers::WIPOffset<EstablishTCPConnection<'bldr>> {
    let mut builder = EstablishTCPConnectionBuilder::new(_fbb);
    builder.add_destport(args.destport);
    builder.finish()
  }


  #[inline]
  pub fn destport(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EstablishTCPConnection::VT_DESTPORT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EstablishTCPConnection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("destport", Self::VT_DESTPORT, false)?
     .finish();
    Ok(())
  }
}
pub struct EstablishTCPConnectionArgs {
    pub destport: i32,
}
impl<'a> Default for EstablishTCPConnectionArgs {
  #[inline]
  fn default() -> Self {
    EstablishTCPConnectionArgs {
      destport: 0,
    }
  }
}

pub struct EstablishTCPConnectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EstablishTCPConnectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_destport(&mut self, destport: i32) {
    self.fbb_.push_slot::<i32>(EstablishTCPConnection::VT_DESTPORT, destport, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EstablishTCPConnectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EstablishTCPConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EstablishTCPConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EstablishTCPConnection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EstablishTCPConnection");
      ds.field("destport", &self.destport());
      ds.finish()
  }
}
pub enum EstablishUnixConnectionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EstablishUnixConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EstablishUnixConnection<'a> {
  type Inner = EstablishUnixConnection<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EstablishUnixConnection<'a> {
  pub const VT_PATH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EstablishUnixConnection { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EstablishUnixConnectionArgs<'args>
  ) -> flatbuffers::WIPOffset<EstablishUnixConnection<'bldr>> {
    let mut builder = EstablishUnixConnectionBuilder::new(_fbb);
    if let Some(x) = args.path { builder.add_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EstablishUnixConnection::VT_PATH, None)}
  }
}

impl flatbuffers::Verifiable for EstablishUnixConnection<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .finish();
    Ok(())
  }
}
pub struct EstablishUnixConnectionArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EstablishUnixConnectionArgs<'a> {
  #[inline]
  fn default() -> Self {
    EstablishUnixConnectionArgs {
      path: None,
    }
  }
}

pub struct EstablishUnixConnectionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EstablishUnixConnectionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EstablishUnixConnection::VT_PATH, path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EstablishUnixConnectionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EstablishUnixConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EstablishUnixConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EstablishUnixConnection<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EstablishUnixConnection");
      ds.field("path", &self.path());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Message<'a> {
  pub const VT_EVENTS_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_EVENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageArgs
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.events { builder.add_events(x); }
    builder.add_events_type(args.events_type);
    builder.finish()
  }


  #[inline]
  pub fn events_type(&self) -> Event {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Event>(Message::VT_EVENTS_TYPE, Some(Event::NONE)).unwrap()}
  }
  #[inline]
  pub fn events(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_EVENTS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_run_command(&self) -> Option<RunCommand<'a>> {
    if self.events_type() == Event::run_command {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RunCommand::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_kill_process(&self) -> Option<KillProcess<'a>> {
    if self.events_type() == Event::kill_process {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { KillProcess::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_establish_tcp_connection(&self) -> Option<EstablishTCPConnection<'a>> {
    if self.events_type() == Event::establish_tcp_connection {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EstablishTCPConnection::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_establish_unix_connection(&self) -> Option<EstablishUnixConnection<'a>> {
    if self.events_type() == Event::establish_unix_connection {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EstablishUnixConnection::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_process_launched(&self) -> Option<ProcessLaunched<'a>> {
    if self.events_type() == Event::process_launched {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ProcessLaunched::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_child_creation_error(&self) -> Option<ChildCreationError<'a>> {
    if self.events_type() == Event::child_creation_error {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ChildCreationError::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_process_terminated(&self) -> Option<ProcessTerminated<'a>> {
    if self.events_type() == Event::process_terminated {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ProcessTerminated::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_tcp_socket_listening(&self) -> Option<TCPSocketListening<'a>> {
    if self.events_type() == Event::tcp_socket_listening {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TCPSocketListening::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn events_as_inotify_path_updated(&self) -> Option<InotifyPathUpdated<'a>> {
    if self.events_type() == Event::inotify_path_updated {
      self.events().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { InotifyPathUpdated::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Event, _>("events_type", Self::VT_EVENTS_TYPE, "events", Self::VT_EVENTS, false, |key, v, pos| {
        match key {
          Event::run_command => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunCommand>>("Event::run_command", pos),
          Event::kill_process => v.verify_union_variant::<flatbuffers::ForwardsUOffset<KillProcess>>("Event::kill_process", pos),
          Event::establish_tcp_connection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EstablishTCPConnection>>("Event::establish_tcp_connection", pos),
          Event::establish_unix_connection => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EstablishUnixConnection>>("Event::establish_unix_connection", pos),
          Event::process_launched => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ProcessLaunched>>("Event::process_launched", pos),
          Event::child_creation_error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ChildCreationError>>("Event::child_creation_error", pos),
          Event::process_terminated => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ProcessTerminated>>("Event::process_terminated", pos),
          Event::tcp_socket_listening => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TCPSocketListening>>("Event::tcp_socket_listening", pos),
          Event::inotify_path_updated => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InotifyPathUpdated>>("Event::inotify_path_updated", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs {
    pub events_type: Event,
    pub events: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      events_type: Event::NONE,
      events: None,
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_events_type(&mut self, events_type: Event) {
    self.fbb_.push_slot::<Event>(Message::VT_EVENTS_TYPE, events_type, Event::NONE);
  }
  #[inline]
  pub fn add_events(&mut self, events: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_EVENTS, events);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("events_type", &self.events_type());
      match self.events_type() {
        Event::run_command => {
          if let Some(x) = self.events_as_run_command() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::kill_process => {
          if let Some(x) = self.events_as_kill_process() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::establish_tcp_connection => {
          if let Some(x) = self.events_as_establish_tcp_connection() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::establish_unix_connection => {
          if let Some(x) = self.events_as_establish_unix_connection() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::process_launched => {
          if let Some(x) = self.events_as_process_launched() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::child_creation_error => {
          if let Some(x) = self.events_as_child_creation_error() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::process_terminated => {
          if let Some(x) = self.events_as_process_terminated() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::tcp_socket_listening => {
          if let Some(x) = self.events_as_tcp_socket_listening() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Event::inotify_path_updated => {
          if let Some(x) = self.events_as_inotify_path_updated() {
            ds.field("events", &x)
          } else {
            ds.field("events", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("events", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod demon


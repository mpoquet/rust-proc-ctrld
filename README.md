# Control Daemon

## Description

This project aims to develop a lightweight and robust distributed application for executing and controlling processes across a set of machines. It will be implemented in both Rust and C. Comparisons between the languages will be made to best meet the requirements. We will refer to this application as a "Control Daemon". The application will use a daemon-based architecture, with a long-running process on each machine, providing a remote control interface.

The structure of the project is as followed : 

```bash
.
├── arborescence.txt
├── c
│   ├── builddir
│   ├── daemon-core.c
│   ├── daemon-features
│   ├── include
│   ├── meson.build
│   └── test
├── flatbuffer
│   └── demon.fbs
├── README.md
├── rust
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
│   └── target
└── tests_python
    ├── demon
    ├── performance_comparison.png
    ├── serialization.py
    ├── test_demon.py
    └── test_overhead.py
```

It is fairly self-explanatory.
The c folder contains the code for the C daemon: daemon-core.c implements the main loop of the daemon, and daemon-features.c includes all the actions performed by the daemon, such as creating processes or serializing/deserializing data.
The include folder contains the .h files.
The meson.build file is used to compile the project.
The test folder contains a few tests written in C. However, the main tests that cover the full set of features are located in the tests_python folder.

The flatbuffer folder contains the FlatBuffer schema used by both daemons.

The tests_python folder includes the daemon subfolder, which contains all the functions for serializing and deserializing messages generated by FlatBuffers.
serialization.py provides serialization/deserialization functions usable in Python, as well as all the necessary data structures.
The test_daemon folder contains regression tests for the daemon’s various features.
Finally, test_overhead performs a test to measure the overhead introduced by the daemon compared to running without it.

## Compile project :

### Rust : 

Go to rust rep

`cargo run --bin run_demon <port>` : command to launch demon on the specify port.  
`cargo run --bin run_client` : command to launch client prototype (not finished).

### C :

Requirements : 
- Flatbuffers >= 25.2.10
- Meson

Clone repo

```bash
git clone https://github.com/mpoquet/rust-proc-ctrld.git
cd c
```

compile 

```bash
meson setup builddir
meson compile -C builddir
```

Or to compile in release mode : 

```bash
meson setup builddir --buildtype=release
meson compile -C builddir
```

execute

```bash
cd builddir
./daemon 8080
```

## How to interact with the daemon :

When lauching the daemon, you have to specify a port to wich it will bind. Then you can interact with it by TCP connection via the language of your choice, given that it support flatbuffer. You can check to test_daemon.py file for more exemple but here is a simple one in python: 

The command data structure looks like this : 

```bash
@dataclass
class Command:
    path: str
    args: List[str]
    envp: List[str]
    flags: int
    stack_size: int
    to_watch: List[Surveillance]
```

To execute a process, for instance echo, we will do this :

```bash
path = "/bin/echo"
args = ["echo", "bonjour"]
envp = []
flags = 0
stack_size = 1024 * 1024
to_watch = []
command = Command(
    path=path,
    args=args,
    envp=envp,
    flags=flags,
    stack_size=stack_size,
    to_watch=to_watch,
)
```

Now that our message has been created we will have to serialize it using the functions generated by flatbuffer following the faltbuffer schema :

```bash
buf=send_command_to_demon(command)
```

Then we have to establish the connection to the daemon. Here, we use the IP adress 127.0.0.1 for local testing. The buffer returned by the serialize function contains the size and the data. The protocole require you to add the size at the beginning of the message : 

```bash
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((IP_address, 8080)) #supposing you chose this port when launching the daemon process
header = buf.size.to_bytes(4, byteorder='little')
client.sendall(header + buf.buffer)
```

That's how you send a message. There are multiple type of message described in the flatbuffer schema : 
- RUNCOMMAND wich can execute a process or start the surveillance of a socket or file
- KILLPROCESS wich kills a process

The daemon can also send messages that you will have te receive and deserialize. Here are the cases when the daemon sends message and a few sequence diagram to help visualize.

The client receive a message when : 
- connecting to the daemon
- the daemon succesfully created a process using clone
- the daemon failed the create a process using clone
- the daemon executed execve weather it ended bad or well you will receive a message
- a process finishes no matter how
- a port or a file is being watched
- a port is no longer being watched (due to a timeout or because we found it)
- an event we wanted has been triggered on a file we were watching

Sequence diagram :

![fonctionnement_normal](https://github.com/user-attachments/assets/3c260952-23fa-44ac-b63e-23bb276f1391)


### Regression Tests :
- Flatbuffers
- pytest

First compile both projects then launch the tests

```bash
cd test_python
pytest test_daemon
```

### Overhead Tests :
- pandas
- seaborn
- scipy

```bash
pytest -s --disable-warnings test_overhead.py
```

## Credit

FORT Alexandre  
MAATI Mohamed-Yâ-Sîn  
FIEUX Telmo  
LAGIER Hadrien  

## License
- Code: Apache-2.0
- Everything else, in particular documentation and measurements: CC-BY-SA-4.0
